# this node blindly follows the local plan generated by nav2
import numpy as np
from numpy.linalg import norm

import rclpy 
from rclpy.node import Node

from nav_msgs.msg import Path
from geometry_msgs.msg import Quaternion, Pose, Twist, Accel
from dasc_msgs.msg import DITrajectory

from .utils_quaternion import angle_between

def twist_between(pose1, pose2, dt):
    # returns a Twist object pose2 - pose1 in time dt
    twist = Twist()
    twist.linear.x = (pose2.position.x  - pose1.position.x) / dt
    twist.linear.y = (pose2.position.y  - pose1.position.y) / dt
    twist.linear.z = (pose2.position.z  - pose1.position.z) / dt

    # for now it ignores the required angular vel

    return twist

def poseDist(start, end):

    dx = norm([
        end.position.x - start.position.x,
        end.position.y - start.position.y,
        end.position.z - start.position.z])

    da = angle_between(start.orientation, end.orientation)

    return dx, da


class BlindFollower(Node):

    def __init__(self):

        super().__init__("blind_follower")

        self.lin_vel = 2.0 # m/s
        self.ang_vel = 2.0 # rad/s
        
        self.sub = self.create_subscription(
                Path, 
                # "/received_global_plan",
                "/local_plan",
                self.plan_callback, 
                10)


        self.pub = self.create_publisher(
                DITrajectory,
                "nominal_traj",
                10)

    def plan_callback(self, msg):
        self.get_logger().info("I heard a message")

        # convert it into a DITrajectory
        traj_msg = DITrajectory()
        traj_msg.header = msg.header

        # copy over the first few poses
        SKIP_INDS = 2
        for (i, stampedPose) in enumerate(msg.poses):
            if i >= SKIP_INDS:
              p = stampedPose.pose
              p.position.z = 0.5 # set z height
              traj_msg.poses.append(p)
              
              traj_msg.twists.append(Twist())
              traj_msg.accelerations.append(Accel())
        

        # determine dt based on the total distance, and the length
        N = len(traj_msg.poses)
        if N <= 1:
            return

        dist_lin, dist_ang = poseDist(traj_msg.poses[0], traj_msg.poses[-1])
        self.get_logger().info(f"dist_lin: {dist_lin}, dist_ang: {dist_ang}")
        traj_msg.dt = max(0.001, max(dist_lin/self.lin_vel/N, dist_ang/self.ang_vel/N))

        self.get_logger().info(f"{traj_msg.dt}")

        # publish
        self.pub.publish(traj_msg)


def main(args = None):

    rclpy.init(args = args)

    node = BlindFollower()

    rclpy.spin(node)

    node.destropy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    # main()

    pose1 = Pose()
    pose1.position.x =1.0
    pose1.orientation.w = 1.0
    pose2 = Pose()
    pose2.orientation.w = 0.924 
    pose2.orientation.z = -0.383 

    dx, da = poseDist(pose1, pose2)

    print(f"dx: {dx}, da: {da}")
